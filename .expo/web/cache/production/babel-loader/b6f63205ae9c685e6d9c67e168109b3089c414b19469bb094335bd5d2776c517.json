{"ast":null,"code":"import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import'abort-controller/polyfill';import{UnavailabilityError}from'expo-modules-core';import ServerRegistrationModule from\"./ServerRegistrationModule\";import{addPushTokenListener}from\"./TokenEmitter\";import getDevicePushTokenAsync from\"./getDevicePushTokenAsync\";import{updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal}from\"./utils/updateDevicePushTokenAsync\";var lastAbortController=null;function updatePushTokenAsync(_x){return _updatePushTokenAsync.apply(this,arguments);}function _updatePushTokenAsync(){_updatePushTokenAsync=_asyncToGenerator(function*(token){var _lastAbortController;(_lastAbortController=lastAbortController)==null?void 0:_lastAbortController.abort();lastAbortController=new AbortController();return yield updateDevicePushTokenAsyncWithSignal(lastAbortController.signal,token);});return _updatePushTokenAsync.apply(this,arguments);}export function setAutoServerRegistrationEnabledAsync(_x2){return _setAutoServerRegistrationEnabledAsync.apply(this,arguments);}function _setAutoServerRegistrationEnabledAsync(){_setAutoServerRegistrationEnabledAsync=_asyncToGenerator(function*(enabled){var _lastAbortController2;(_lastAbortController2=lastAbortController)==null?void 0:_lastAbortController2.abort();if(!ServerRegistrationModule.setRegistrationInfoAsync){throw new UnavailabilityError('ServerRegistrationModule','setRegistrationInfoAsync');}yield ServerRegistrationModule.setRegistrationInfoAsync(enabled?JSON.stringify({isEnabled:enabled}):null);});return _setAutoServerRegistrationEnabledAsync.apply(this,arguments);}export function __handlePersistedRegistrationInfoAsync(_x3){return _handlePersistedRegistrationInfoAsync.apply(this,arguments);}function _handlePersistedRegistrationInfoAsync(){_handlePersistedRegistrationInfoAsync=_asyncToGenerator(function*(registrationInfo){var _registration;if(!registrationInfo){return;}var registration=null;try{registration=JSON.parse(registrationInfo);}catch(e){console.warn('[expo-notifications] Error encountered while fetching registration information for auto token updates.',e);}if(!((_registration=registration)!=null&&_registration.isEnabled)){return;}try{var latestDevicePushToken=yield getDevicePushTokenAsync();yield updatePushTokenAsync(latestDevicePushToken);}catch(e){console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.',e);}});return _handlePersistedRegistrationInfoAsync.apply(this,arguments);}if(ServerRegistrationModule.getRegistrationInfoAsync){addPushTokenListener(function(){var _ref=_asyncToGenerator(function*(token){try{var registrationInfo=yield ServerRegistrationModule.getRegistrationInfoAsync();if(!registrationInfo){return;}var registration=JSON.parse(registrationInfo);if(registration!=null&&registration.isEnabled){yield updatePushTokenAsync(token);}}catch(e){console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.',e);}});return function(_x4){return _ref.apply(this,arguments);};}());ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);}else{console.warn(\"[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.\",new UnavailabilityError('ServerRegistrationModule','getRegistrationInfoAsync'));}","map":{"version":3,"names":["UnavailabilityError","ServerRegistrationModule","addPushTokenListener","getDevicePushTokenAsync","updateDevicePushTokenAsync","updateDevicePushTokenAsyncWithSignal","lastAbortController","updatePushTokenAsync","_x","_updatePushTokenAsync","apply","arguments","_asyncToGenerator","token","_lastAbortController","abort","AbortController","signal","setAutoServerRegistrationEnabledAsync","_x2","_setAutoServerRegistrationEnabledAsync","enabled","_lastAbortController2","setRegistrationInfoAsync","JSON","stringify","isEnabled","__handlePersistedRegistrationInfoAsync","_x3","_handlePersistedRegistrationInfoAsync","registrationInfo","_registration","registration","parse","e","console","warn","latestDevicePushToken","getRegistrationInfoAsync","_ref","_x4","then"],"sources":["/Users/jinwook/react-native/daily-pt-frontend/node_modules/expo-notifications/src/DevicePushTokenAutoRegistration.fx.ts"],"sourcesContent":["import 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\n\nlet lastAbortController: AbortController | null = null;\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Abort current update process\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param enabled\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  lastAbortController?.abort();\n\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n\n  await ServerRegistrationModule.setRegistrationInfoAsync(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n// note(Chmiela): This function is exported only for testing purposes.\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  // A global scope (to get all the updates) device push token\n  // subscription, never cleared.\n  addPushTokenListener(async (token) => {\n    try {\n      // Before updating the push token on server we always check if we should\n      // Since modules can't change their method availability while running, we\n      // can assert it's defined.\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync!();\n\n      if (!registrationInfo) {\n        // Registration is not enabled\n        return;\n      }\n\n      const registration: DevicePushTokenRegistration | null = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        // Dispatch an abortable task to update\n        // registration with new token.\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n        e\n      );\n    }\n  });\n\n  // Verify if persisted registration\n  // has successfully uploaded last known\n  // device push token. If not, retry.\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\n    `[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`,\n    new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync')\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}